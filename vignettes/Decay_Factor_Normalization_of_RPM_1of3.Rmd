---
title: "_RNAdecay_ Vignette 1: Decay Factor Normalization of RNA-seq RPM data for Decay Modeling"
author: "Reed Sorenson | reed.sorenson@utah.edu | Department of Biology | University of Utah"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Decay Factor Normalization of RNA-seq RPM data for Decay Modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The functions and code of the `RNAdecay` package were written for the purpose of analyzing decreasing levels of RNA abundance as measured by RNA short read sequencing (aka RNA-seq) after inhibition of transcription. Tissue is treated to block transcription (e.g., using a chemical such as cordycepin or ActinomycinD) and tissue is collected at regular intervals (referred to as the RNA decay time course, e.g., T0, T30, T60 refer to 0, 30, and 60 min of blocked transcription). Total RNA is extracted from the tissue and measured by RNA-seq. Although we wrote this package to analyze RNA-seq data, it could also be adapted to analyze individual gene data from quantitative reverse rranscription polymerase chain reaction (qRT-PCR) measures, however, normalization (as herein described) is best performed using a number of stable reference genes. 

Raw (Illumina) RNA-seq data are typically libraries made of up 10M-250M short (50 nt) sequences. These sequences are aligned to the genome and counted based on the location of their alignment in annotated genomic ranges (e.g., genes, exons, etc). Read counts for each gene are normalized to the size of their respective RNA-seq library for comparison to libraries generated from other biological material, therefore, read counts are expressed as reads per million (RPM).  We begin RNA decay analysis in this package with RPM RNA abundance data. 

## 1. T0 NORMALIZATION
Prior to modeling RNA decay, we normalize the read counts to the initial (T0) RNA abundance, the transcript level just prior to blocking transcription. This is unique for each gene and in an experiment with multiple replicates (reps), we use the mean value for all T0 reps. All RPM values in the time course are divided by the mean T0 value. For example:

```{r}
# you can see that in this fabricated data the RNAs have a half-life of ~30 min
RPM_geneX = data.frame(T0 = c(150, 135, 148), T30 = c(72, 76, 69), T60 = c(35, 35, 30), 
                     row.names = paste0("rep", 1:3))
RPM_geneX
RPM_geneX_T0norm = RPM_geneX/mean(RPM_geneX$T0)
RPM_geneX_T0norm
colMeans(RPM_geneX_T0norm)
```

The following workflow simplifies this process on an example data set included in this package (from Sorenson et al., 2017) which we will use throughout the vignettes. It has 4 genotypes, 8 time points, and 4 biological replicates for 128 samples (columns) and 118 genes (rows). This script demends on column names consisting of unique, non-nested variable tags separated by underscores ('_'), rownames are gene ID's. 
```{r}
library(RNAdecay)
RPMs[1:2, c(1:11, 128)] # built-in example data
# NOTE: not showing all columns here
```

Biological replicate data columns are indexed using the `cols()` function.
```{r}
cols(RPMs, "WT", "00") #gives the column indices that contain both tags in the column names

colnames(RPMs)[cols(RPMs, "WT", "00")]

# NOTE: this is based on grep pattern matching so tags MUST be unique and non-overlapping (i.e. one entire label should not be part of another).
```

Replicate samples' mean and standard error (SE) data.frames are generated by looping over label combinations and binding the values together.
```{r}
# create a directory for results output
wrdir = "~/DecayAnalysis/Example analysis results 1"
if(!file.exists(wrdir)) dir.create(wrdir, recursive = TRUE)

# specify sample tags from colnames of RPMs
treatment = c("WT", "sov", "vcs", "vs") # NOTE: I did not use 'vcs sov' for the name of the double mutant, or cols(RPMs, "vcs", "00") would have indexed all T0 samples of both "vcs" and "vcs" sov"; instead, I used 'vs'.
reps = c("r1", "r2", "r3", "r4")
tdecay = c("00", "07", "15", "30", "60", "120", "240", "480") #again NO nesting of one label in another hence "00" instead of "0".
```

Loop over the treatments and timepoints to subset the appropriate columns, and calculate mean and SE of replicates.
```{r}
mean_RPM = data.frame("geneID" = rownames(RPMs))
SE_RPM = data.frame("geneID" = rownames(RPMs))
for(g in treatment){
  for(t in tdecay){
    mean_RPM = cbind(mean_RPM, rowMeans(RPMs[, cols(RPMs, g, t)]))
    names(mean_RPM)[length(mean_RPM)] = paste0(g, "_", t)
    SE_RPM = cbind(SE_RPM, apply(X = RPMs[, cols(RPMs, g, t)], MARGIN = 1, FUN = stats::sd)/sqrt(length(reps)))
    names(SE_RPM)[length(SE_RPM)] = paste0(g, "_", t)
  }}
mean_RPM[1:2, ]
SE_RPM[1:2, ]
# write output to file
write.table(x = mean_RPM, paste0(wrdir, "/RPM_mean.txt"), sep = "\t")
write.table(x = SE_RPM,   paste0(wrdir, "/RPM_SE.txt"), sep = "\t")
```

Optionally, an RPM-based filtering step could be applied at this point to remove lowly expressed genes, for example.
```{r}
filt1 = rep(TRUE, 118) # we will not filter in this example, so the filter value for each gene is set to TRUE.
```

Replicate samples' mean T0 RPM values are then used to normalize gene level data.
```{r}
mT0norm = data.frame(row.names = rownames(RPMs)[filt1])
for(g in treatment){
  mean_T0reps = rowMeans(RPMs[filt1, cols(RPMs, g, "00")])
  for(r in reps){
    df = RPMs[filt1, colnames(RPMs)[cols(RPMs, g, r)]]
    df = df[, 1:length(tdecay)]/mean_T0reps
    mT0norm = cbind(mT0norm, df)
  }}
write.table(x = mT0norm, file = paste0(wrdir, "/mean T0 normalized.txt"),  sep = "\t")

```

Replicate samples' mean and SE data.frames are then calculated on the T0 normalized data.
```{r}
mean_mT0norm = data.frame(row.names = rownames(mT0norm))
for(g in treatment){
  for(t in tdecay){
    mean_mT0norm = cbind(mean_mT0norm, rowMeans(mT0norm[, cols(mT0norm, g, t)]))
    names(mean_mT0norm)[length(names(mean_mT0norm))] = paste0(g, "_", t)
  }}

SE_mT0norm = data.frame(row.names = rownames(mT0norm))
for(g in treatment){
  for(t in tdecay){
    SE_mT0norm = cbind(SE_mT0norm, apply(X = mT0norm[, cols(mT0norm, g, t)], MARGIN = 1, FUN = function(x) stats::sd(x)/sqrt(length(reps))))
    names(SE_mT0norm)[length(names(SE_mT0norm))] = paste0(g, "_", t)
  }}

# write output to file
write.table(x = mean_mT0norm, file = paste0(wrdir, "/mean T0 normalized_Mean.txt"),  sep = "\t")
write.table(x = SE_mT0norm, file = paste0(wrdir, "/mean T0 normalized_SE.txt"),  sep = "\t")
```

## 2. DECAY FACTOR CORRECTION

After inhibition of RNA synthesis,the total pool of RNA in cells decreases as degradation proceeds. As this occurs, very stable RNAs become a much larger proportion of the total RNA pool even though their concentration in the cell remains nearly constant. RNA-seq library normalization scales reads to library size (i.e. to the total RNA pool) and, because of this, abundance of stable RNAs appears to increase. The apparent increase in abundance of stable genes is proportional to the reduction in the total pool of RNA, so we can use it to apply a correction to the data. We call this decay factor correction. The decay factor is estimated based on the RPM increase (relative to the T0 samples) of a set of stable and abundant reference genes.

We selected 30 genes with high abundance on which to calculate the decay factors for each sample. These were then used to correct abundance in each of the respective samples. A unique decay factor is calculated for each treatment at each time point.

First, make a vector of 'geneID's of abundant and stable reference genes. 
```{r}
stablegenes = c( "ATCG00490", "ATCG00680", "ATMG00280", "ATCG00580", "ATCG00140", "AT4G38970", "AT2G07671", "ATCG00570", "ATMG00730", "AT2G07727", "AT2G07687", "ATMG00160" ,"AT3G11630", "ATMG00060", "ATCG00600", "ATMG00220", "ATMG01170", "ATMG00410", "AT1G78900", "AT3G55440", "ATMG01320", "AT2G21170" ,"AT5G08670", "AT5G53300", "ATMG00070", "AT1G26630", "AT5G48300", "AT2G33040", "AT5G08690", "AT1G57720")
```

Mean T0 normalized values of stable genes are then pulled out of the `mean_mT0norm` data.frame and used to calculate the decay factor for each set of replicate samples.
```{r}
stabletable = mean_mT0norm[stablegenes, ]
normFactors = colMeans(stabletable)
write.table(x = normFactors, paste0(wrdir, "/Normalziation Factors.txt"), sep = "\t")
normFactors_mean = matrix(normFactors, nrow = length(tdecay))
normFactors_SE = matrix(apply(X = stabletable, MARGIN = 2, function(x) stats::sd(x)/sqrt(length(stablegenes))), nrow = length(tdecay))
t.decay = c(0, 7.5, 15, 30, 60, 120, 240, 480)
rownames(normFactors_mean) = t.decay
rownames(normFactors_SE) = t.decay
colnames(normFactors_mean) = treatment
colnames(normFactors_SE) = treatment
list(normalizationFactors = normFactors_mean, SE = normFactors_SE)
```

Generate a matrix of the same dimensions as `mT0norm` with the appropriate decay factors in the same respective positions.
```{r}
nF = vector()
ind = sapply(names(normFactors), function(x) grep(x, colnames(mT0norm)))
for(i in 1:ncol(ind)){
nF[ind[, i]] = colnames(ind)[i]
}
normFactorsM = t(matrix(rep(normFactors[nF], nrow(mT0norm)), ncol = nrow(mT0norm)))
rm(nF, ind)
```

Apply the decay factor corrections.
```{r}
mT0norm_2 = data.frame(mT0norm/normFactorsM, 
                     row.names = rownames(mT0norm))

write.table(mT0norm_2, paste0(wrdir, "/mean T0 normalized and decay factor corrected.txt"), sep = "\t")
```

Rearrange the RNA decay data into a long form data.frame for modeling and visualization.
```{r}
mT0norm_2.1 = reshape2::melt(as.matrix(mT0norm_2), varnames = c("geneID", "variable"))
mT0norm_2.1 = cbind(mT0norm_2.1, reshape2::colsplit(mT0norm_2.1$variable, "_", names = c("treatment", "t.decay", "rep")))

mT0norm_2.1 = mT0norm_2.1[, colnames(mT0norm_2.1) !=  "variable"]
mT0norm_2.1 = mT0norm_2.1[, c(1, 3, 4, 5, 2)]
colnames(mT0norm_2.1) = c("geneID", "treatment", "t.decay", "rep", "value")
mT0norm_2.1$rep = gsub("r", "rep", mT0norm_2.1$rep)
mT0norm_2.1$t.decay = as.numeric(gsub("7", "7.5", as.numeric(mT0norm_2.1$t.decay)))
mT0norm_2.1$treatment = factor(mT0norm_2.1$treatment,levels = c("WT","sov","vcs","vs"))
mT0norm_2.1$rep = factor(mT0norm_2.1$rep, levels = paste0("rep",1:4))
write.table(x = mT0norm_2.1,  file = paste0(wrdir, 
"/ExampleDecayData+stableGenes.txt"), sep = "\t")
```

Following the steps in this vignettes, the resulting normalized data frame should be identical to the one supplied in this package called decaydata. To check:
```{r}
table(RNAdecay::decaydata[,1:4] == mT0norm_2.1[,1:4]) # should be all TRUE no FALSE
```

The normalized data is now ready to be used for modeling decay rates described in _RNAdecay Vignette 2: RNA Decay Modeling_. 
