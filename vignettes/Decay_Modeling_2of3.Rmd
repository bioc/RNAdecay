---
title: "_RNAdecay_ Vignette 2: RNA Decay Modeling"
author: "Reed Sorenson | reed.sorenson@utah.edu | Department of Biology | University of Utah"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RNA Decay Modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

RNA degradation is typically modeled with a constant exponential decay model. This model assumes a constant decay rate throughout the decay time course. However, a number of issues might violate this assumption. For example, decay might depend on continuous transcription of rapidly turned over components of decay  machinery; inhibition of this transcription would cause slowed decay due to lost supply of decay components. Alternatively, decay rate might be regulated (e.g., diurnally) leading to a slow change in decay rate over a long time course evaluating decay. Decay feedback due to slowed transcription could also lead to slowing decay. We, therefore, apply both a constant exponential decay model and a time-dependent exponential decay model. However, besides these possibilies, other distinct mechanisms could lead to an apparent slowing of RNA decay. For example, because RNA-seq reads are pooled from multiple cell types and mapped to genes, distinct gene mRNA subpopulations might have different decay rates (i.e., different splice isoforms, or the same mRNA in different cell types of a multicellular organism) that are not separately measured but averaged.  We believe that for these the time-dependent exponential decay model will also better capture this average than a constant exponential decay model. 

The dynamic nature of RNA decay can be a point of gene regulation. To identify treatments that might affect decay rate, we model all possibilities of treatment effect on both [initital] decay rates ($\alpha$) and decay of decay rates ($\beta$) using maximum likelihood modeling to estimate the parameters of decay for each treatment. 

This is done by running the modeling with constraints on treatment decay rates (i.e., constraining decay rates of treatments to be equal or allowing them to combinatorially vary in  independent groups). This can be done with up to four treatments in this package. Modeling is done gene by gene with each set of constraints, and then the models are compared using the AICc statistic. In this package, we refer to these as equivalence constraint  groupings. 

For the detailed mathematical framework of the decaying decay model see Sorenson et. al. (2018). Below we describe the steps of the algorithmic implementation and walk though an example data set. 

## 3. LOAD NORMALIZED AND CORRECTED DATA AND CHECK THE FORMAT
[For steps 1 (normalization) and 2 (decay factor correction) see _RNAdecay Vignette 1: Decay Factor Normalization of RNA-seq RPM data for Decay Modeling_ in this package.] 

The following script requires a data.frame with five columns with the following column names exactly: "geneID", "treatment", "t.decay", "rep", "value":
* geneID    = gene identifiers (`factor`)
* treatment = experimental treatment or genotype (`factor`)
* t.decay   = time after transcriptional inhibition (`numeric`)
* rep       = biological replicate number (`factor`)
* value     = RNA abundance normalized to library size, decay factor and mean T0 values (`numeric`)
```{r}
library(RNAdecay)

# make new directory for results
wrdir = "~/DecayAnalysis/Example analysis results 2"
if(!file.exists(wrdir)) dir.create(wrdir, recursive = TRUE)
```

Rename factor levels and specify level order of `decaydata$treatment` for sorting and making figures. The example data set is already ordered, but when data is read from a text file (e.g., .csv) factor levels are ordered automatically and should be reordered according to user preference now to avoid later headaches.
```{r}
levels(decaydata$treatment) # This can not be longer than 4 elements

# decaydata$treatment = factor(decaydata$treatment, levels = levels(decaydata$treatment)[c(4, 1, 2, 3)]) # numbers here refer to the current order position in the factor levels() - the order of the numbers designates the new position

levels(decaydata$treatment)[4] = "vcs.sov"
levels(decaydata$treatment)
```

Sort the `decaydata` data.frame as follows (*REQUIRED step for proper indexing below*).
```{r}
decaydata = decaydata[order(decaydata$t.decay), ]
decaydata = decaydata[order(decaydata$rep), ]
decaydata = decaydata[order(as.numeric(decaydata$treatment)), ] 
decaydata = decaydata[order(decaydata$geneID), ]
ids = as.character(unique(decaydata$geneID)) # 118 in example set
decaydata[1:10, ]
```


## 4. GENERATE MATRICES OF $\alpha$ AND $\beta$ EQUIVALENCE GROUPS
Create objects and set varables used in the modeling based on `decaydata`.
```{r}
# (no changes needed here - just execute the code)
nEquivGrp = if (length(unique(decaydata$treatment)) == 2) {2} else
  if (length(unique(decaydata$treatment)) == 3) {5} else 
    if (length(unique(decaydata$treatment)) == 4) {15}
genoSet = 1:(length(unique(decaydata$rep)) * length(unique(decaydata$t.decay)))
nTreat = length(unique(decaydata$treatment))
nSet = length(genoSet)*nTreat
groups = groupings(decaydata)
mods = data.frame(
  "a" = as.vector(sapply(1:nEquivGrp, function(x) {rep(x, nEquivGrp + 1)})),
  "b" = rep(1:(nEquivGrp + 1), nEquivGrp),
  row.names = paste0("mod", 1:(nEquivGrp*(nEquivGrp+1)))
)
```

Determine the bounds for $\alpha$ and $\beta$ parameters. The bounds on $\alpha$ and $\beta$ are related to distinguishing constant decay, and decaying decay as described in the modeling supplement (Sorenson et. al., _PNAS_, 2018). 

Care should be taken in determining these bounds given each experimental design. We have provided functions to aid in selection of the lower bounds of $\alpha$ and $\beta$ (`a.low` and `b.low`, respectively), and upper bound for $\alpha$ (`a.high`). These functions calculate limits based on the time points data were collected. For example, if abundance for an unstable mRNA is measured at the first time point to be 0.02% of the initial (T0) abundance, the information needed to estimate this decay rate was not collected. So, `a.high()` caluclates the maximum estimatable decay rate based on the time at which the first decay data point was collected. Similarly, the lower bound for $\beta$ is required to distinguish the constant decay model (Exp()) from the decaying decay model (dExp()). The upper bound for $\beta$ is required to distinguish the no decay model (Exp(0,t)) from decaying decay model. If $\beta$ is too small 1-exp(-$\beta$\*t) ~ -$\beta$\*t and c(t) ~ exp(-$\alpha$\*t), we can't distinguish between constant decay and decaying decay models. If $\beta$ is too big 1-exp(-$\beta$\*t) ~ 1 and c(t) ~ exp(-$\alpha$/$\beta$), a constant, we can't distinguish between no decay and decaying decay models. Refer to the supplement for more detail about how we calculated the bound for $\alpha$ and $\beta$ (Sorenson et. al., _PNAS_, 2018).

```{r}
a.bounds = c(a.low(max(decaydata$t.decay)), a.high(min(unique(decaydata$t.decay)[unique(decaydata$t.decay)>0])))
b.bounds = c(b.low(max(decaydata$t.decay)), 0.075)
a.bounds;b.bounds
```

Create a colormap of model groups.
```{r}
groupMap(decaydata = decaydata, path = paste0(wrdir, "/Model grouping colormap.pdf"), nEquivGrp = nEquivGrp, groups = groups, mods = mods)
```
This file (Model grouping colormap.pdf) should now be in your working directory. This color map is a reference for understanding model constraints. For example, model 1 has all different colored boxes representing unconstrained $\alpha$s and unconstrained betas, whereas,  the second to last model has only two box colors - one for all $\alpha$s indicating that they all have constrained equivalence and the other indicating that all $\beta$s also have constrained equivalence. 1st order model $\beta$s = 0 which is indicated with gray color. 


## 5. MODELING

Modeling is accomplished using the `modOptimization()` function. The function takes as arguments, the gene identifier, $\alpha$ and $\beta$ bounds, the `decaydata` data.frame, a vector of model names (e.g., as `c("mod1", "mod239", ... )`, the equivalence constraint matrix (defined as `groups` above), and a matrix to specify which contstraint groupings to use for $\alpha$ and $\beta$ parameters (defined as `mods` above), respectively, for each model, and a results folder (which will be made if it doesn't already exist) to which the results are written. A number of other arguments are available as well, see help file for details using `?modOptimization`.  

Efficient model parameter optimization is accomplished using objective functions coded as binary dynamically linked libraries. These libraries are compiled from functions coded in the C++ language on each machine using functionality of the `TMB` package.

First, compile the C++ source code into dynamically linked library (\*.dll, for Windows) or shared object (\*.so, linux and Mac) files for each of the objective functions. This only needs to be done once on your machine after installation of the package. Compiling C++ code requires a compiler be installed separatedly on your system (e.g., Rtools34 or later for Windows,  https://cran.r-project.org/bin/windows/Rtools/; Xcode comand line tools for Mac, http://railsapps.github.io/xcode-command-line-tools.html; R development package for Linux, r-base-dev). If you don't already have one of these installed, stop and install one and restart R. C++ source files are located in the installed 'RNAdecay/src' folder. The compiled files should also be written to this same folder.

```{r}
# only run once after installing RNAdecay pacakage
src_files = dir(paste0(find.package("RNAdecay"), "/src"), full.names = TRUE)
for (i in src_files) {TMB::compile(i)}
```

Load the compiled dynamically linked libraries. 
```{r}
libs = gsub(".cpp", "", dir(paste0(find.package("RNAdecay"), "/src"), pattern = ".cpp", full.names = TRUE))
for (i in libs) {dyn.load(TMB::dynlib(i))}
```

Next, test the modeling on a couple of genes on a handful of models. 
```{r}
modOptimization("AT2G18150", decaydata, group = groups, mod = mods, a.bounds, b.bounds, c("mod1", "mod2", "mod16", "mod239", "mod240"), file.only = FALSE) 
modOptimization("AT4G09680", decaydata, group = groups, mod = mods, a.bounds, b.bounds, c("mod1", "mod2", "mod16", "mod239", "mod240"), file.only = FALSE) 
```

Next, run all the models on each and every gene. This requires significant computational resources depending on data set size, number of models, and computing speed. The sample data set has 8 time points x 4 replicates each x 4 treatments (= 128 samples) for 118 genes and requires about 10 h processor time. 20000 genes at ~5 min each is ~70 d processor time, so be sure to test a few different models on a few handfuls of genes to feel comfortable running all the modeling. We recommend parallel processing (on multiple processor cores) using `parallel::mclapply` to cut overall time. If this function is unavailable on your machine (e.g., on _Windows_) you can use lapply, but it will take much longer. `modOptimization()` writes results to file in tab-delimited form and, optionally, can also return them as a data.frame object. 
```{r}
####### To run all genes in parallel use:
# parallel::mclapply(ids, FUN = modOptimization, 
#                    data = decaydata, group = groups, mod = mods, 
#                    alpha.bounds = a.bounds, beta.bounds = b.bounds,
#                    models = paste0("mod", 1:240), 
#                    path = paste0(wrdir, "/modeling_results"),
#   mc.cores = getOption("mc.cores",  15L), # set the number of compute cores to use here (e.g., 9L = 9 cores, 11L = 11 cores)
#   mc.preschedule = TRUE,
#   mc.set.seed = TRUE,
#   mc.silent = FALSE,
#   mc.cleanup = TRUE,
#   mc.allow.recursive = TRUE)
```

The entire example data set takes ~ 10 h processor time with lapply so for this example we will randomly select one gene ID to run here. 
```{r}
test.ids = sample(ids, 1) # NOTE: that everytime this line is run it generates a different random sampling, therefore the gene modeled below will be different each time this code is run. To test the exact gene shown in the vignette make a new character vector of the gene id reported below and pass it to the gene argument of modOptimization using lapply instead of passing 'test.ids' as we do here.  
test.ids

a = proc.time()[3]
models = lapply(X = test.ids, # alternatively use `ids` here to complete the entire sample data set, but be prepared to wait 10 h. These gene IDs will get passed one at time to the "gene" argument of modOptimization() and return a list of the results data.frame.
                FUN = modOptimization,
                data = decaydata, 
                group = groups, 
                mod = mods,
                alpha.bounds = a.bounds, 
                beta.bounds = b.bounds,
                models = rownames(mods), 
                path = paste0(wrdir, "/modeling_results"),
                file.only = FALSE) 
names(models) = test.ids
b = proc.time()[3]
(b-a)/60/length(test.ids) # gives you average min per gene 
```

For each gene, read in the results data frame written by `modOptimization()` as an element of a single list object.
```{r}
models = lapply( paste0( wrdir, "/modeling_results/", test.ids, "_results.txt"), read.delim, header = TRUE )   
names(models) = test.ids
```


## 6. MODEL SELECTION

The AICc statistic is used to compare model performance. Better models have lower AICc values. Select a single model for each gene based on the lowest AICc statistic. We will continue here with the `RNAdecay::models` data included in the package which uses all 118 genes from the sample data set `RNAdecay::decaydata`.
```{r}
models = RNAdecay::models # built-in data, comment this line out to continue with your own modelling output
results = t(sapply(models, function(x) x[x[, "AICc"]==min(x[, "AICc"]), ]))
results = as.data.frame(results)
results[, 1:2] = sapply(as.data.frame(results[, 1:2]), function(x) as.character(unlist(x)))
results[, -c(1,2)] = sapply(results[, -c(1,2)], unlist)
write.table(results, file = paste0(wrdir,"/best model results.txt"), sep = "\t")
results = read.delim(paste0(wrdir,"/best model results.txt"))
```

Generate some graphics to visualize results.
```{r}
library(ggplot2)
pdf(paste0(wrdir,"/distributions of stats.pdf"))
p = ggplot(results)
print(p+geom_histogram(aes(x = sigma2), bins = 300)+
        xlim(0,0.5)+
        geom_vline(xintercept = 0.0625)+
        myTheme())
print(p+stat_bin(aes(x = sigma2), breaks = c(seq(0,0.25,0.25/50),Inf), geom = "bar"))
print(p+stat_ecdf(aes(sigma2), geom = "line")+
        xlim(c(0,sqrt(0.5))))
print(p+stat_ecdf(aes(sqrt(sigma2)), geom = "line")+
        xlim(c(0,0.5)))
print(p+geom_histogram(aes(x = range.LL), bins = 60))
print(p+geom_histogram(aes(x = nUnique.LL), bins = 60))
dev.off()

pdf(paste0(wrdir,"/lowest AICc model counts.pdf"), height = 8, width = 32)
p = ggplot(data = data.frame(
  model = as.integer(gsub("mod","",names(table(results$mod)))),
  counts = as.integer(table(results$mod))))+
  geom_bar(aes(x = model, y = counts), stat = "identity")+
  scale_x_continuous(limits = c(0,nrow(mods)), breaks = seq(0,nrow(mods),5))+
  ggtitle("Model distribution of absolute lowest AICs")
print(p+myTheme(25))
dev.off()
```

Because two models are considered to perform differently if their AICc value difference is >2, any models that have AICc values within two of the model with the lowest AICc are considered to have performed similarly. The number of models performing similarly to the best model are plotted as a histogram here. The number of different alpha groupings represented in these models is also plotted.   
```{r}
minMods = sapply(models, function(x) which (x[, "AICc"] < (2+min(x[, "AICc"])))) 
minAMods = lapply(minMods, function(x) unique(mods[x, "a"]))

pdf(paste0(wrdir,"/number of models that performed similar to the one selected.pdf"))
barplot(height = table(sapply(minMods, length)), xlab = "No. models in the lowest AICc group (not more than 2 different from lowest)",
        ylab = "No. genes")
barplot(height = table(sapply(minAMods, length)), xlab = "No. alpha groups in the lowest AICc group (not more than 2 different from lowest)",
        ylab = "No. genes")
dev.off()
```

Build the modeling results data.frame. Group genes with similar $\alpha$ groupings and then group genes with similar $\beta$ groupings.
```{r}
results = read.delim(paste0(wrdir,"/best model results.txt"))
results$alpha_grp = mods[as.character(results$mod), "a"]
results$beta_grp = mods[as.character(results$mod), "b"]
results$mod = as.numeric(gsub("mod", "", as.character(results$mod)))

results$alphaPattern = sapply(rownames(results), function(x) {
  paste0(gsub("alpha_", "", colnames(results)[3:(2+nTreat)][order(round(results[x, 3:(2+nTreat)], 4))]), collapse = "<=")
  })
results$alphaPattern = paste0(results$alpha_grp, "_", results$alphaPattern)
results$betaPattern = sapply(rownames(results), function(x){
  paste0(gsub("beta_", "", colnames(results)[(3+nTreat):(2+2*nTreat)][order(round(results[x, (3+nTreat):(2+2*nTreat)], 4))]), collapse = "<=")
  })
results$betaPattern = paste0(results$beta_grp, "_", results$betaPattern)

results = results[order(rownames(results)), ]
results = results[order(results$beta_grp), ]
results = results[order(results$alphaPattern), ]
results = results[order(results$alpha_grp), ]

results$alphaPattern = factor(results$alphaPattern, levels = as.character(unique(results$alphaPattern)))

results = data.frame(results[, 3:(2*nTreat+3), 2], results[, c("AICc", "alpha_grp", "beta_grp", "alphaPattern", "betaPattern")])
results$nEqMods = sapply(minMods[rownames(results)], length)
results$nEqAgp = sapply(minAMods[rownames(results)], length)

# Customize: add columns of relative alphas and betas as desired, e.g.:
results$rA_sov.WT    = results$alpha_sov      / results$alpha_WT
results$rA_vcs.WT    = results$alpha_vcs      / results$alpha_WT
results$rA_vcssov.WT = results$alpha_vcs.sov  / results$alpha_WT

write.table(results, paste0(wrdir,"/alphas+betas+mods+grps+patterns+relABs.txt"), sep = "\t")

results = read.delim(paste0(wrdir,"/alphas+betas+mods+grps+patterns+relABs.txt"), header = TRUE, colClasses =  c(NA, rep("numeric", 2+2*nTreat), rep("integer", 2), rep("character", 2), rep("integer", 2), rep("numeric", 3)))
# results$alpha_subgroup = factor(results$alpha_subgroup, levels = unique(results$alpha_subgroup))
results$alphaPattern = factor(results$alphaPattern, levels = unique(results$alphaPattern))
results$betaPattern = factor(results$betaPattern, levels = unique(results$betaPattern))
results[1:3, ]
```

All files were written to the `wrdir`. The modeling results are now ready to be visualized using `DecayPlotter` as described in _RNAdecay Vignette 3: Decay Plotter_.
